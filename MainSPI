/* 
 * File:   Main.c
 * Author: applet
 *
 * Created on January 26, 2015, 3:23 PM
 */

#include <stdio.h>
#include <stdlib.h>

/*
 * 
 */


// PIC18F25K22 Configuration Bit Settings

// 'C' source line config statements


// PIC18F25K22 Configuration Bit Settings

// 'C' source line config statements

#include <p18F25K22.h>
#include <usart.h>
#include <spi.h>
#include "tomIsLaw.h"

//LOCAL NODE SPI SETUP
#define SPI_SCK LATCbits.LATC3//clock output, C7
#define SPI_SDO  LATCbits.LATC5 //Serial Data Output, C6
#define SPI_SDI PORTCbits.RC4 //Serial Data Input, C5
#define SPI_COMMANDER LATAbits.LATA5 //chip select, RA5

//GLOBAL THINGS
#define VOLT 0xAA //hey remote node, you OK bro?
#define AFFR 0x0C //remote node: "yeah man"
#define QUER 0xC0 

unsigned char tomStar;
int main(int argc, char** argv) {
    int turboPhail;
    turboPhail = 0;
    //initialize stuff we did
    Setup();
    Menu();
    
   // putrs1USART("[?] Print Duty Cycle %!\r\n");
    
    //test();
    //test(); //IO test code

    //the primary functionality of local node: SPI COMMAND HQ
    turboPhail = SPI_KNIGHT_COMMANDER();
    //^^returns int if we exit for some reason (reason to be given by int value)
   
    return (turboPhail);
}

void Menu(){

   putc1USART(0x0C);
    putrs1USART("AHT Mobile Medical\r\n");
    putrs1USART("--=Control Scheme=--\r\n");
    putrs1USART("[0-5] Volt. Presets\r\n");
    putrs1USART("[w] Increment +.02 V\r\n");
    putrs1USART("[s] Decrement -.02 V\r\n");
    putrs1USART("[x] Memory Recall\r\n");
    putrs1USART("[z] DEGAUSS!\r\n");
    return;
}
void Setup(){
   /* STEP 1: in which we try to turn on the SPI
    * SPI_FOSC_4: SPI Master mode, clock = FOSC/4
    * MODE_10: data transmitted on rising edge (of what? SCLK?)
    * SMPEND: means that we sample input data at END of output
    */
    OpenSPI1( SPI_FOSC_64, MODE_00, SMPMID );
    
    TRISBbits.TRISB0 = 0;
    TRISBbits.TRISB1 = 0;
    TRISCbits.RC6 = 0;
    TRISCbits.RC7 = 1;
    //TRISAbits.TRISA7 = 1;
    //OSCCON = OSCCON | 0x01;
    ANSELA=0;
    ANSELB=0;
    ANSELC=0;
   // ANSELD=0;
   // STEP 2: USART SETUP

   Open1USART(USART_TX_INT_OFF &
              USART_RX_INT_OFF &
              USART_ASYNCH_MODE &
              USART_EIGHT_BIT &
              USART_CONT_RX &
              USART_BRGH_LOW,
              129);

    /* SRAM setup stuff */

   //Control signals
   TRISAbits.TRISA0 = 0; //!CS
   TRISAbits.TRISA1 = 0; //!OE
   TRISAbits.TRISA2 = 0; //!WE

   PORTAbits.RA0 = 1; //!CS disabled
   PORTAbits.RA1 = 1; //!OE disabled
   PORTAbits.RA2 = 1; //!WE disabled

   //address bits
   TRISAbits.TRISA3 = 0; //addr0
   TRISAbits.TRISA4 = 0; //addr1
   //TRISAbits.TRISA7 = 0; //addr1
   //TRISAbits.TRISA6 = 0; //addr1

   PORTAbits.RA3 = 0;
   PORTAbits.RA4 = 0;
  // PORTAbits.RA7 = 0;
   //PORTAbits.RA6 = 0;

   //IO bits
   //all are initially set to be inputs
   TRISB = 0xFF;
   //all are initially low
   PORTBbits.RB0 = 0;
   PORTBbits.RB0 = 0;
   PORTBbits.RB0 = 0;
   PORTBbits.RB0 = 0;
   PORTBbits.RB0 = 0;
   PORTBbits.RB0 = 0;
   PORTBbits.RB0 = 0;
 
}
int SPI_KNIGHT_COMMANDER(void){
//unsigned char array[] = "This crap sucks";
    int phailDetectorUnit;
    int i;
    unsigned char tomLord;
    //char failLord;
    unsigned char inByte[2];
    unsigned char setValue[5];
    unsigned int longOut;
    unsigned char outByteH;
    unsigned char outByteL;
    unsigned char package[3];
    int percentage;
    unsigned char tomTest[2];
    unsigned char upperStorage;
    unsigned char lowerStorage;
    unsigned char test[2];
    unsigned char bilko[3];
    bilko[2] = 0;
    
    i=0;


    inByte[1] = 0;
    setValue[4] = 0;
    //numberInputs=0;
    //outByte[1] = 0;
    //failLord = 0xBE;
    //phailDetectorUnit = 0;

   // PORTBbits.RB1=0;

    //outByte = 0xFF;
   // localMemory(outByte,0,0)


   // putrs1USART("\r\nApplehansontaft: Crap Systems LTD");
    longOut = 0x02;
   
    while(1){
        gets1USART(inByte,1);
        //sprintf(numInputs,"%d",numberInputs);
       // writeSRAM(numInputs[0],0);
        //NOTE TO US: STICKY (REQUIRES TWO BUTTON PRESSES)!
        //increment by no more than .5%
        if(inByte[0] == 'w') {
            if (longOut < 1023) longOut = longOut + 1;
            //store record of increment (0xAA) command and resulting longOut
            upperStorage = 0xA;//upper 4 bits of longout
            lowerStorage = (longOut & 0x3F); //lower 6 bits of longOut
            writeSRAM(upperStorage,1);
            writeSRAM(lowerStorage,3);
            putrs1USART("+.025V\r\n");
        }
        //decrement by no more than .5%
        else if (inByte[0] == 's'){
            if (longOut > 1) longOut = longOut - 1;
            //store record of decrement (0xBB) command and resulting longOut
            upperStorage = 0xB; //upper 4 bits of longout
            lowerStorage = (longOut & 0x3F); //lower 6 bits of longOut
            writeSRAM(upperStorage,1);
            writeSRAM(lowerStorage,3);
            putrs1USART("-.025V\r\n");
        }
        //PRESETS
        else if (inByte[0]=='0'){ //TURN IT OFF!!! TURN IT OFF!!!!
            longOut = 1;
            putrs1USART("0 V \r\n");
            upperStorage = 0x1;
            writeSRAM(upperStorage,1);
        }
        else if (inByte[0]=='1'){
            longOut = 205; //205
            putrs1USART("1 V \r\n");
            upperStorage = 0x2;
            writeSRAM(upperStorage,1);
        }
        else if (inByte[0]=='2'){
            longOut = 411; //411
            putrs1USART("2 V \r\n");
            upperStorage = 0x3;
            writeSRAM(upperStorage,1);
           
        }
        else if (inByte[0]=='3'){
            longOut = 613; //613
            putrs1USART("3 V \r\n");
            upperStorage = 0x4;
            writeSRAM(upperStorage,1);
           
        }
        else if (inByte[0]=='4'){
            longOut = 823; //823
            putrs1USART("4 V \r\n");
            upperStorage = 0x5;
            writeSRAM(upperStorage,1);

           
        }
        else if (inByte[0]=='5'){ //FULL POWER!!!!!
            longOut = 1023;
            putrs1USART("5 V \r\n");
            upperStorage = 0x6;
            writeSRAM(upperStorage,1);
        
        }
        else if (inByte[0]=='x'){
            putrs1USART("Memory recall (WIP)\r\n");
            upperStorage = readSRAM(1);
           // lowerStorage = readSRAM(1);
            if (upperStorage == 0xA) putrs1USART("incremented +.25\r\n");
  
            if (upperStorage == 0xB) putrs1USART("decremented -.25\r\n");

            if (upperStorage == 0x1) putrs1USART("Preset 0 V\r\n");

            if (upperStorage == 0x2) putrs1USART("Preset 1 V\r\n");

            if (upperStorage == 0x3) putrs1USART("Preset 2 V\r\n");

            if (upperStorage == 0x4) putrs1USART("Preset 3 V\r\n");

            if (upperStorage == 0x5) putrs1USART("Preset 4 V\r\n");

            if (upperStorage == 0x6) putrs1USART("Preset 5 V\r\n");
            
        } else if (inByte[0]=='z') {
            Menu();
      
        } else if (inByte[0]=='l'){
            printf("Duty cycle is %d\r\n",longOut);
        } else if (inByte[0]=='?'){
            percentage = (longOut/1024)*100;
            printf("Duty cycle is %d\r\n",percentage);
        }

         if (((RCSTA1 >> 1) & 0x1) != 0)// TOM'S OVERFLOW ERROR DETECTOR
         {
            RCSTA1 ^ 0x2;
           // printf("TEST");
            tomCheapassFix(0);
            tomCheapassFix(1);
         }
        outByteL = (unsigned char)((longOut & 0x003)<<4);
        outByteH = (unsigned char)((longOut & 0x3FC)>>2);


  
        SSP1BUF = outByteL;
        while (!SSP1STATbits.BF);
        bilko[0] = SSP1BUF;
        //sprintf(bilko[0],"%s",bilko[0]);
     
        SSP1BUF = outByteH;
        while (!SSP1STATbits.BF);

        if (bilko[0]=0xFF) putrs1USART("ADC KINDA WORKING\n");
   
      
 
    }
return phailDetectorUnit;
}
void writeSRAM(unsigned char data, int address){
/*TRISAbits.RA0 = 0 //!CS
   TRISAbits.RA1 = 0; //!OE
   TRISAbits.RA2 = 0; //!WE
   TRISAbits.RA3 = 0; //latch
 */
    int delay;
   // unsigned char addr0;
    //unsigned char addr1;
    //unsigned char addr2;
    //unsigned char addr3;

   // addr0 = (address & 0x01);
   // addr1 = (address >> 1) & 0x01;
   // addr2 = (address >> 2) & 0x01;
   // addr3 = (address >> 3) & 0x01;


    PORTAbits.RA0 = 0; //SRAM enabled
    PORTAbits.RA1 = 1; //not outputing
    PORTAbits.RA2 = 1; //writing TO the SRAM

    //PORTAbits.RA3 = addr0;
    //PORTAbits.RA4 = addr1;

    //IO pins set to be outputs
    TRISB = 0x00;

    LATB = address;

    PORTAbits.RA3 = 1; //latch address
    PORTAbits.RA3 = 0; //de-latch address

   


    //PORTAbits.RA3 = addr0;
    //PORTAbits.RA4 = addr1;
   // PORTAbits.RA7 = addr0;
    //PORTAbits.RA6 = addr1;
    LATB = data;

    PORTAbits.RA2 = 0; //writing TO the SRAM

    PORTAbits.RA2 = 1; //not writing TO the SRAM
    PORTAbits.RA0 = 1; //SRAM disabled

    //IO pins reset to be inputs
    TRISB = 0xff;
}

unsigned char readSRAM(int address){
    /*TRISAbits.RA0 = 0 //!CS
   TRISAbits.RA1 = 0; //!OE
   TRISAbits.RA2 = 0; //!WE
   TRISAbits.RA3 = 0; //addr0
   TRISAbits.RA4 = 0; //addr1
 */
    //unsigned char addr0;
    //unsigned char addr1;
    //unsigned char addr2;
    //unsigned char addr3;
    unsigned char toSender;
    int delay;
    //addr0 = (address & 0x01);
    //addr1 = (address >> 1) & 0x01;
    //addr2 = (address >> 2) & 0x01;
    //addr3 = (address >> 3) & 0x01;
    //IO pins set to inputs
    TRISB = 0x00;

    PORTAbits.RA0 = 0; //SRAMw enabled
    PORTAbits.RA1 = 1; //not outputing
    PORTAbits.RA2 = 1; //writing TO the SRAM

    //LATA = address;
    LATB = address;
    PORTAbits.RA3 = 1;
    PORTAbits.RA3 = 0;
    
    TRISB = 0xFF;
    
   // PORTAbits.RA3 = addr0;
    //PORTAbits.RA4 = addr1;
    //PORTAbits.RA7 = addr0;
    //PORTAbits.RA6 = addr1;

    PORTAbits.RA1 = 0; //output is a GO!

    //give some time to read
    toSender = PORTB;
    //disable everything

    PORTAbits.RA0 = 1; //SRAM disabled
    PORTAbits.RA1 = 1; //not outputing

    return toSender;
}

void tomCheapassFix(int toggle){
    if (toggle){
         Open1USART(USART_TX_INT_OFF &
              USART_RX_INT_OFF &
              USART_ASYNCH_MODE &
              USART_EIGHT_BIT &
              USART_CONT_RX &
              USART_BRGH_LOW,
              129);
    } else {
        Close1USART();
    }

}
