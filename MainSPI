/* 
 * File:   Main.c
 * Author: applet
 *
 * Created on January 26, 2015, 3:23 PM
 */

#include <stdio.h>
#include <stdlib.h>

/*
 * 
 */


// PIC18F25K22 Configuration Bit Settings

// 'C' source line config statements


// PIC18F25K22 Configuration Bit Settings

// 'C' source line config statements

#include <p18F25K22.h>
#include <usart.h>
#include <spi.h>
#include "tomIsLaw.h"

//LOCAL NODE SPI SETUP
#define SPI_SCK LATCbits.LATC3//clock output, C7
#define SPI_SDO  LATCbits.LATC5 //Serial Data Output, C6
#define SPI_SDI PORTCbits.RC4 //Serial Data Input, C5
#define SPI_COMMANDER LATAbits.LATA5 //chip select, RA5

//GLOBAL THINGS
#define VOLT 0xAA //hey remote node, you OK bro?
#define AFFR 0x0C //remote node: "yeah man"
#define QUER 0xC0 

unsigned char tomStar;
int main(int argc, char** argv) {
    int turboPhail;
    turboPhail = 0;
    //initialize stuff we did
    Setup();
    putc1USART(0x0C);
    putrs1USART("AHT Mobile Medical\r\n");
    putrs1USART("[0-5] Volt. Presets\r\n");
    putrs1USART("[w] +.02 V\r\n");
    putrs1USART("[s] -.02 V\r\n");
    
    //test();
    //test(); //IO test code

    //the primary functionality of local node: SPI COMMAND HQ
    turboPhail = SPI_KNIGHT_COMMANDER();
    //^^returns int if we exit for some reason (reason to be given by int value)
   
    return (turboPhail);
}


void Setup(){
   /* STEP 1: in which we try to turn on the SPI
    * SPI_FOSC_4: SPI Master mode, clock = FOSC/4
    * MODE_10: data transmitted on rising edge (of what? SCLK?)
    * SMPEND: means that we sample input data at END of output
    */
    OpenSPI1( SPI_FOSC_64, MODE_00, SMPMID );
    
    TRISBbits.TRISB0 = 0;
    TRISBbits.TRISB1 = 0;
    TRISCbits.RC6 = 0;
    TRISCbits.RC7 = 1;
    //TRISAbits.TRISA7 = 1;
    //OSCCON = OSCCON | 0x01;
    ANSELA=0;
    ANSELB=0;
    ANSELC=0;
   // ANSELD=0;
   // STEP 2: USART SETUP

   Open1USART(USART_TX_INT_OFF &
              USART_RX_INT_OFF &
              USART_ASYNCH_MODE &
              USART_EIGHT_BIT &
              USART_CONT_RX &
              USART_BRGH_LOW,
              129);

    /* SRAM setup stuff */

   //Control signals
   TRISAbits.TRISA0 = 0; //!CS
   TRISAbits.TRISA1 = 0; //!OE
   TRISAbits.TRISA2 = 0; //!WE

   PORTAbits.RA0 = 1; //!CS disabled
   PORTAbits.RA1 = 1; //!OE disabled
   PORTAbits.RA2 = 1; //!WE disabled

   //address bits
   TRISAbits.TRISA3 = 0; //addr0
   TRISAbits.TRISA4 = 0; //addr1
   //TRISAbits.TRISA7 = 0; //addr1
   //TRISAbits.TRISA6 = 0; //addr1

   PORTAbits.RA3 = 0;
   PORTAbits.RA4 = 0;
  // PORTAbits.RA7 = 0;
   //PORTAbits.RA6 = 0;

   //IO bits
   //all are initially set to be inputs
   TRISB = 0xFF;
   //all are initially low
   PORTBbits.RB0 = 0;
   PORTBbits.RB0 = 0;
   PORTBbits.RB0 = 0;
   PORTBbits.RB0 = 0;
   PORTBbits.RB0 = 0;
   PORTBbits.RB0 = 0;
   PORTBbits.RB0 = 0;
 
}
int SPI_KNIGHT_COMMANDER(void){
//unsigned char array[] = "This crap sucks";
    int phailDetectorUnit;
    int i;
    unsigned char tomLord;
    //char failLord;
    unsigned char inByte[2];
    unsigned char setValue[5];
    unsigned int longOut;
    unsigned char outByteH;
    unsigned char outByteL;
    unsigned char package[3];
    int percentage[2];

    unsigned char upperStorage;
    unsigned char lowerStorage;
    i=0;


    inByte[1] = 0;
    setValue[4] = 0;
    //numberInputs=0;
    //outByte[1] = 0;
    //failLord = 0xBE;
    //phailDetectorUnit = 0;

   // PORTBbits.RB1=0;

    //outByte = 0xFF;
   // localMemory(outByte,0,0);
    percentage[1] = 0;


   // putrs1USART("\r\nApplehansontaft: Crap Systems LTD");
    longOut = 0xFF;
   
    while(1){
        gets1USART(inByte,1);
        //sprintf(numInputs,"%d",numberInputs);
       // writeSRAM(numInputs[0],0);
        //NOTE TO US: STICKY (REQUIRES TWO BUTTON PRESSES)!
        //increment by no more than .5%
        if(inByte[0] == 'w') {
            if (longOut < 1023) longOut = longOut + 1;
            //store record of increment (0xAA) command and resulting longOut
            upperStorage = 0xA;//upper 4 bits of longout
            lowerStorage = (longOut & 0x3F); //lower 6 bits of longOut
            writeSRAM(upperStorage,1);
            writeSRAM(lowerStorage,3);
    
        }
        //decrement by no more than .5%
        else if (inByte[0] == 's'){
            if (longOut > 1) longOut = longOut - 1;
            //store record of decrement (0xBB) command and resulting longOut
            upperStorage = 0xB; //upper 4 bits of longout
            lowerStorage = (longOut & 0x3F); //lower 6 bits of longOut
            writeSRAM(upperStorage,1);
            writeSRAM(lowerStorage,3);
            
        }
        //PRESETS
        else if (inByte[0]=='0'){ //TURN IT OFF!!! TURN IT OFF!!!!
            longOut = 1;
        }
        else if (inByte[0]=='1'){
            longOut = 205; //205
 
          
        }
        else if (inByte[0]=='2'){
            longOut = 411; //411
         
           
        }
        else if (inByte[0]=='3'){
            longOut = 615; //615
         
           
        }
        else if (inByte[0]=='4'){
            longOut = 819; //819
         
           
        }
        else if (inByte[0]=='5'){ //FULL POWER!!!!!
            longOut = 1023;
        
        }
        else if (inByte[0]=='x'){
            upperStorage = readSRAM(1);
           // lowerStorage = readSRAM(1);
            if (upperStorage == 0xA){
                putrs1USART("last incremented\r\n");
            }
            if (upperStorage == 0xB) {
                putrs1USART("last decremented\r\n");
            }
        }
        
         if (((RCSTA1 >> 1) & 0x1) != 0)// TOM'S OVERFLOW ERROR DETECTOR
         {
            RCSTA1 ^ 0x2;
            printf("TEST");
         }
        //set point: 5
       /// else if (inByte[])
        outByteL = (unsigned char)((longOut & 0x003)<<4);
        outByteH = (unsigned char)((longOut & 0x3FC)>>2);
        
        package[0] = outByteL;
        package[1] = outByteH;
        package[2] = 0;
        
        putsSPI1(package);
        //outByte[0] = readSRAM(0);
        //outByte[1] = 0;
       //// puts1USART(outByte);
        //while (0 != (WriteSPI(0x55)));
        
    }
return phailDetectorUnit;
}
void writeSRAM(unsigned char data, int address){
/*TRISAbits.RA0 = 0 //!CS
   TRISAbits.RA1 = 0; //!OE
   TRISAbits.RA2 = 0; //!WE
   TRISAbits.RA3 = 0; //addr0
   TRISAbits.RA4 = 0; //addr1
 */
    unsigned char addr0;
    unsigned char addr1;
    unsigned char addr2;
    unsigned char addr3;
    int delay;

    addr0 = (address & 0x01);
    addr1 = (address >> 1) & 0x01;
    addr2 = (address >> 2) & 0x01;
    addr3 = (address >> 3) & 0x01;
    
    PORTAbits.RA0 = 0; //SRAM enabled
    PORTAbits.RA1 = 1; //not outputing
    PORTAbits.RA2 = 1; //writing TO the SRAM

    //PORTAbits.RA3 = addr0;
    //PORTAbits.RA4 = addr1;

    //IO pins set to be outputs
    TRISB = 0x00;

    PORTAbits.RA3 = addr0;
    PORTAbits.RA4 = addr1;
   // PORTAbits.RA7 = addr0;
    //PORTAbits.RA6 = addr1;
    LATB = data;

    PORTAbits.RA2 = 0; //writing TO the SRAM

    PORTAbits.RA2 = 1; //not writing TO the SRAM
    PORTAbits.RA0 = 1; //SRAM disabled

    //IO pins reset to be inputs
    TRISB = 0xff;
}

unsigned char readSRAM(int address){
    /*TRISAbits.RA0 = 0 //!CS
   TRISAbits.RA1 = 0; //!OE
   TRISAbits.RA2 = 0; //!WE
   TRISAbits.RA3 = 0; //addr0
   TRISAbits.RA4 = 0; //addr1
 */
    unsigned char addr0;
    unsigned char addr1;
    unsigned char addr2;
    unsigned char addr3;
    unsigned char toSender;
    int delay;
    addr0 = (address & 0x01);
    addr1 = (address >> 1) & 0x01;
    addr2 = (address >> 2) & 0x01;
    addr3 = (address >> 3) & 0x01;
    //IO pins set to inputs
    TRISB = 0xFF;

    PORTAbits.RA0 = 0; //SRAMw enabled
    PORTAbits.RA1 = 1; //not outputing
    PORTAbits.RA2 = 1; //writing TO the SRAM

    //LATA = address;
    PORTAbits.RA3 = addr0;
    PORTAbits.RA4 = addr1;
    //PORTAbits.RA7 = addr0;
    //PORTAbits.RA6 = addr1;

    PORTAbits.RA1 = 0; //output is a GO!

    //give some time to read
    toSender = PORTB;
    //disable everything

    PORTAbits.RA0 = 1; //SRAM disabled
    PORTAbits.RA1 = 1; //not outputing

    return toSender;
}
